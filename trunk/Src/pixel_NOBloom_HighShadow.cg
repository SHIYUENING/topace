//Fragment Shader

// Note how the fragment struct was simply copied from our vertex shader code.
// This is necessary if we want to use a vertex and pixel shader together.

struct fragment
{
    float4 position	:	POSITION;
    float4 color0	:	COLOR0;
    float2 texcoord0	:	TEXCOORD0;
    float3 normal	:	TEXCOORD1;
    float4 objectPos	:	TEXCOORD2;
    float2 texcoord3	:	TEXCOORD3;
	float4 objectPos2	:	TEXCOORD4;
	float3 Light2color	:	TEXCOORD5;
};

struct pixel
{
    float4 color : COLOR;
};

pixel main( 
    fragment IN, 
    uniform float3	globalAmbient,
    uniform float3	paraLightColor,
    uniform float3	paraLightDirection,
    uniform float3	eyePosition,
//    uniform float3	Ke,
//    uniform float3	Ka,
//    uniform float3	Kd,
//    uniform float3	Ks,

//	uniform float	testnum,
//    uniform float	shininess,
    uniform sampler2D	testTexture,
    uniform sampler2D	ShadowMapTexture,
	uniform samplerCUBE	AmbientReflectiveTexture,
	uniform sampler2D	NormalMapTexture,
	uniform sampler2D	SpecularMapTexture
)
{
	float3 T = normalize(IN.color0);
	float3 Nm = normalize(IN.normal);
	float3 B = normalize(cross (T,Nm));
	float3x3 TBN;
	TBN[0]=T;
	TBN[1]=B;
	TBN[2]=Nm;
	float3 NN = tex2D( NormalMapTexture, IN.texcoord0 ).xyz;
	float3 NN2;
	NN2.x=(NN.x-0.5)*2.0;
	NN2.y=(NN.y-0.5)*2.0;
	NN2.z=(NN.z-0.5)*2.0;
    float3 P = IN.position.xyz;
    float3 N = mul(NN2,TBN);

    float3 L = normalize(paraLightDirection-P);
    float diffuseLight = max(dot(N, L), 0);
    float3 diffuse = paraLightColor * diffuseLight;

    float3 V = normalize(eyePosition - P);
    float3 H = normalize(L + V);
    float specularLight = pow(max(dot(N, H), 0), 50.0);
	float4 SpecularMapcolor;
	SpecularMapcolor=tex2D( SpecularMapTexture, IN.texcoord0 );

    if(diffuseLight<=0) specularLight=0;
    float4 Ocolor;
	//Ocolor.xyz = globalAmbient + diffuse+specularLight*8*SpecularMapcolor.xyz;
    Ocolor.w = 1.0;
    pixel OUT;
	float tmp0,tmp1;
	float4 colorposZ;
	float posz;
	float v=0.001;
	tmp1=0.995+0.005*2.0;
	float2 MX=float2 (v,0);
	float2 MU=float2 (0,v);
	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3+MX );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3-MX );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3+MU );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3-MU );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3+MX+MU );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3-MX+MU );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3+MX-MU );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3-MX-MU );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3+MX*2 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3-MX*2 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3+MU*2 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3-MU*2 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3+MX*2+MU*2 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3-MX*2+MU*2 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3+MX*2-MU*2 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3-MX*2-MU*2 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3+MX*3 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3-MX*3 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3+MU*3 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;

	colorposZ=tex2D( ShadowMapTexture, IN.texcoord3-MU*3 );
	posz=(colorposZ.r*255.0+colorposZ.g+colorposZ.b/255.0)*tmp1;
	if(IN.objectPos2.z>posz) tmp0=tmp0+1;
	half3 I = IN.objectPos2.xyz - eyePosition;
	half3 R = reflect(I, N);
	Ocolor.xyz=globalAmbient +IN.Light2color+(diffuse+specularLight*8*SpecularMapcolor.xyz)*(21-tmp0)/21;




	OUT.color = tex2D( testTexture, IN.texcoord0 )*Ocolor*(texCUBE( AmbientReflectiveTexture, R)+1.0);

    return OUT;
}
