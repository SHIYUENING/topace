<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0039)http://tvmet.sourceforge.net/usage.html -->
<HTML><HEAD><TITLE>Tiny Vector Matrix library using Expression Templates</TITLE>
<META http-equiv=Content-Type content=text/html;charset=iso-8859-1><!-- This Tiny Vector and Matrix C++ template libary uses Meta Templates and
    Expression Templates to evaluate results at compile time - to make it fast
    for low order (tiny) systems. -->
<META 
content="This Tiny Vector and Matrix C++ template&#10;    libary uses Meta Templates and Expression Templates to evaluate results&#10;    at compile time - to make it fast for low order (tiny) systems." 
name=description>
<META 
content="tiny, vector, matrix, fast, C++, STL, template, library,&#10;    expression templates, meta templates, fixed size, fixed dimension,&#10;    matrix-matrix, matrix-vector, vector-matrix, binary, unary, operations, operators,&#10;    product, transpose, linear algebra, cross product, dot product, type promotion,&#10;    exception, linux, kernel, embedded system, regression test, gcc, g++,&#10;    blitz, blitz++, TinyVector, TinyMatrix, MTL, TNT,&#10;    gnu compiler suite, portland group c++, kai c++, intel compiler, LGPL" 
name=keywords><LINK 
href="Tiny Vector Matrix library using Expression Templates.files/tvmet.css" 
type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2900.5512" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD vAlign=center align=left width="20%"><A 
      href="http://sourceforge.net/projects/tvmet"><IMG height=37 
      alt="SourceForge Logo" src="" width=125 border=0></A> </TD>
    <TD vAlign=center align=middle width="50%"><B><BIG>T</BIG>iny 
      <BIG>V</BIG>ector <BIG>M</BIG>atrix library using <BIG>E</BIG>xpression 
      <BIG>T</BIG>emplates</B> </TD>
    <TD vAlign=center align=right width="20%"><A 
      href="http://tvmet.sourceforge.net/">Sourceforge Project Page</A> 
  </TD></TR></TBODY></TABLE>
<HR>
<!-- Generated by Doxygen 1.5.2 -->
<DIV class=tabs>
<UL>
  <LI><A 
  href="http://tvmet.sourceforge.net/index.html"><SPAN>Main&nbsp;Page</SPAN></A> 

  <LI><A 
  href="http://tvmet.sourceforge.net/modules.html"><SPAN>Modules</SPAN></A> 
  <LI><A 
  href="http://tvmet.sourceforge.net/namespaces.html"><SPAN>Namespaces</SPAN></A> 

  <LI><A 
  href="http://tvmet.sourceforge.net/classes.html"><SPAN>Classes</SPAN></A> 
  <LI><A href="http://tvmet.sourceforge.net/files.html"><SPAN>Files</SPAN></A> 
  <LI><A 
  href="http://tvmet.sourceforge.net/pages.html"><SPAN>Related&nbsp;Pages</SPAN></A> 

  <LI>
  <FORM action=search.php method=get>
  <TABLE cellSpacing=0 cellPadding=0 border=0>
    <TBODY>
    <TR>
      <TD><LABEL>&nbsp;<U>S</U>earch&nbsp;for&nbsp;</LABEL></TD>
      <TD><INPUT accessKey=s 
name=query></TD></TR></TBODY></TABLE></FORM></LI></UL></DIV>
<H1><A class=anchor name=usage>Usage</A></H1>Contents:
<OL type=1>
  <LI><A class=el href="http://tvmet.sourceforge.net/usage.html#include">Include 
  files</A>
  <LI><A class=el 
  href="http://tvmet.sourceforge.net/usage.html#construct">Construction and 
  Initializing</A>
  <LI><A class=el href="http://tvmet.sourceforge.net/usage.html#c_arrays">Use of 
  C style Arrays with tvmet</A>
  <LI><A class=el href="http://tvmet.sourceforge.net/usage.html#compare">Compare 
  Vectors and Matrices</A>
  <LI><A class=el href="http://tvmet.sourceforge.net/usage.html#pod">Data Types 
  like std::complex&lt;&gt;</A>
  <LI><A class=el href="http://tvmet.sourceforge.net/usage.html#stl">STL 
  support</A>
  <LI><A class=el 
  href="http://tvmet.sourceforge.net/usage.html#matrix_access">Matrix access by 
  rows and columns</A>
  <LI><A class=el 
  href="http://tvmet.sourceforge.net/usage.html#expr_print">Expression 
  printing</A></LI></OL>
<H2><A class=anchor name=include>Include files</A></H2>The Tiny Vector and 
Matrix template library has many include files spread throughout the tvmet 
include directory. As a user, you need only include 
<CODE>&lt;tvmet/Vector&gt;</CODE> for vector operations and/or 
<CODE>&lt;tvmet/Matrix&gt;</CODE> for matrix operations.
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment><SPAN class=preprocessor>   #include &lt;<A class=code href="http://tvmet.sourceforge.net/Matrix_8h.html">tvmet/Matrix.h</A>&gt;</SPAN>
<SPAN class=preprocessor>   #include &lt;<A class=code href="http://tvmet.sourceforge.net/Vector_8h.html">tvmet/Vector.h</A>&gt;</SPAN>

   <SPAN class=keyword>using namespace </SPAN>tvmet;
</PRE></DIV></DD></DL>Simple, isn't it? Don't forget to use the namespace <A 
class=el 
title="The namespace for the Tiny Vector Matrix using Expression Templates Libary." 
href="http://tvmet.sourceforge.net/namespacetvmet.html">tvmet</A>, but keep in 
mind that using the using directive inside headers will pollute the namespace. 
If you write this in a header file, the namespace for all subsequent header 
files (those which include the one you're writing) will also be polluted. (This 
is not a tvmet specific phenomenon.) Therefore, write the using statement in the 
C++ file.
<H2><A class=anchor name=construct>Construction and Initializing</A></H2>Due to 
the nature of <A 
href="http://extreme.indiana.edu/~tveldhui/papers/Expression-Templates/exprtmpl.html>">Expression 
Templates</A> (ET) you can't write code like
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <A class=code title="Compile time fixed length vector with evaluation on compile time." href="http://tvmet.sourceforge.net/classtvmet_1_1Vector.html">tvmet::Vector&lt;double, 3&gt;</A> v1(1,2,3);  <SPAN class=comment>// OK</SPAN>
   <A class=code title="Compile time fixed length vector with evaluation on compile time." href="http://tvmet.sourceforge.net/classtvmet_1_1Vector.html">tvmet::Vector&lt;double, 3&gt;</A> v2 = v1;    <SPAN class=comment>// not possible</SPAN>
</PRE></DIV></DD></DL>The operator= function assigns an expression to the Vector 
which means that the object must be constructed before you may assign something 
to it. The solution is to write this as:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keyword>using namespace </SPAN>tvmet;

   Vector&lt;double, 3&gt; v1(1,2,3);
   Vector&lt;double, 3&gt; v2;        <SPAN class=comment>// construct the Vector&lt;T,Sz&gt; object at first</SPAN>
   v2 = v1;                     <SPAN class=comment>// ... and assign the contents of v1 to v2</SPAN>
   Vector&lt;double, 3&gt; v3(v1);    <SPAN class=comment>// ... or simple use the copy constructor</SPAN>

   std::cout &lt;&lt; v3 &lt;&lt; std::endl;
</PRE></DIV></DD></DL>since the object v2 needs to be constructed before the 
object's operator=() can be called.
<P>The same rule applies to the Matrix class. You can only assign vectors and 
matrices of the same dimension or you will get a compile error. This also 
applies to the argument list for the constructor of the classes.
<P>Initializing can be done as shown above or by using a comma separated list:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keyword>using namespace </SPAN>tvmet;

   Matrix&lt;double, 3, 2&gt; m1;     <SPAN class=comment>// yes, non-square matrices are possible as well</SPAN>
   m1 = 1, 4,
        2, 5,
        3, 6;
</PRE></DIV></DD></DL>Matrix element initialization always performed column 
wise! If the length of the comma separated list is longer than the storage size, 
you will get a compile time error. (<A class=el 
title="The namespace for the Tiny Vector Matrix using Expression Templates Libary." 
href="http://tvmet.sourceforge.net/namespacetvmet.html">tvmet</A> is designed to 
prevent this -- it will prevent you from accidentally overwriting memory which 
does not belong to the matrix you are initializing.) You can use a comma 
separated list to initialize vectors as well.
<P>If you want a clean (zero-valued) vector or matrix you can simple write:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keyword>using namespace </SPAN>tvmet;

   Vector&lt;double, 3&gt; v4(0);
   Matrix&lt;double, 3, 4&gt; m2(0);
</PRE></DIV></DD></DL>All elements of v4 and m2 are initialized with zero (or 
whatever value you provide at construction time). Keep in mind that the 
uninitialized Matrix and Vector classes will have random data when the are 
created (since they use a static array for internal storage) unless you 
initialize them!
<P>Another way to initialize a vector or matrix follows:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keyword>using namespace </SPAN>tvmet;

   Vector&lt;double, 3&gt; v5(1,2,3);
   Vector&lt;double, 3&gt; v6(v5);
   Vector&lt;double, 3&gt; v7(v5+v6);
</PRE></DIV></DD></DL>This is useful for temporary results. The result will be 
immediately assigned to the new vector elements using the expression passed to 
the constructor.
<P>Yet another way of initializing a vector or matrix is similar to the above. 
We assign an expression to it:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keyword>using namespace </SPAN>tvmet;

   Matrix&lt;double, 3, 3&gt; m3, m4, m5;
   m3 = 1, 2, 3,
        4, 5, 6,
        7, 8, 9;
   m4 = m3;
   m5 = m3 + m4;
</PRE></DIV></DD></DL>If you have your data inside arrays you can use tvmet's 
iterator interface to initialize a vector or matrix with it:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keywordtype>double</SPAN> data[] = { 1,4,7,
                     2,5,8,
                     3,6,9 };

   std::size_t sz = <SPAN class=keyword>sizeof</SPAN>(data)/<SPAN class=keyword>sizeof</SPAN>(<SPAN class=keywordtype>double</SPAN>);
   <SPAN class=keywordtype>double</SPAN>* first = data;
   <SPAN class=keywordtype>double</SPAN>* last = data + sz;

   <A class=code title="A tiny matrix class." href="http://tvmet.sourceforge.net/classtvmet_1_1Matrix.html">tvmet::Matrix&lt;double, 3, 3&gt;</A>  m(first, last);
</PRE></DIV></DD></DL>The data will be copied into the matrix itself. When the 
constructor has finished, there will be no stored reference to the array 
pointer.
<P>Starting with <A class=el 
title="The namespace for the Tiny Vector Matrix using Expression Templates Libary." 
href="http://tvmet.sourceforge.net/namespacetvmet.html">tvmet</A> release 1.6.0 
you can create an identity matrix simply by using the function <A class=el 
title="Fill a matrix to an identity matrix (convenience wrapper for matrix typedefs)." 
href="http://tvmet.sourceforge.net/group____unary__function.html#g6bc53ab34fcf3e9a6923b386877235a6">identity()</A>. 
Note, we have to specify the matrix type, since ADL can't work here.
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keyword>typedef</SPAN> Matrix&lt;double,3,3&gt;   matrix_type;
   ...
   matrix_type E( identity&lt;matrix_type&gt;() );
</PRE></DIV></DD></DL>
<H2><A class=anchor name=c_arrays>Use of C style Arrays with 
tvmet</A></H2>Sometimes you have some data arranged in a C style array for 
matrices and vectors. As with <A class=el 
title="The namespace for the Tiny Vector Matrix using Expression Templates Libary." 
href="http://tvmet.sourceforge.net/namespacetvmet.html">tvmet</A> release 1.6.0 
you can wrap an expression around using the functions cvector_ref(const T* mem) 
and cmatrix_ref(const T* mem) where mem is the pointer to the C array.
<P>The returned expressions (XprVector or XprMatrix) can be used as usual like 
tvmet's vectors and matrices. This means, you can use all mathematical functions 
on it.
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keyword>static</SPAN> <SPAN class=keywordtype>float</SPAN> lhs[3][3] = {
     {-1,  0,  1}, { 1,  0,  1}, {-1,  0, -1}
   };
   <SPAN class=keyword>static</SPAN> <SPAN class=keywordtype>float</SPAN> rhs[3][3] = {
     { 0,  1,  1}, { 0,  1, -1}, { 0, -1,  1}
   };
   ...

   <SPAN class=keyword>typedef</SPAN> <A class=code title="A tiny matrix class." href="http://tvmet.sourceforge.net/classtvmet_1_1Matrix.html">tvmet::Matrix&lt;float, 3, 3&gt;</A>     matrix_type;

   matrix_type M( <A class=code title="Function for the matrix-matrix-product." href="http://tvmet.sourceforge.net/group____binary__function.html#g26982ad3d80885174f2a22958721d203">prod</A>(cmatrix_ref&lt;float, 3, 3&gt;(&amp;lhs[0][0]),
                       cmatrix_ref&lt;float, 3, 3&gt;(&amp;rhs[0][0])) );
</PRE></DIV></DD></DL>This allows to initialize tvmet's vectors and matrices by 
an alternative way as described at <A class=el 
href="http://tvmet.sourceforge.net/usage.html#construct">Construction and 
Initializing</A>.
<P>Well, the functions <A class=el 
title="Creates an expression wrapper for a C like vector arrays." 
href="http://tvmet.sourceforge.net/group____unary__function.html#g92ecd4f59cded17ea7f5bd479a35fb01">tvmet::cvector_ref</A> 
and <A class=el title="Creates an expression wrapper for a C like matrices." 
href="http://tvmet.sourceforge.net/group____unary__function.html#g248019eaa2111cacd4cf8263038d9c90">tvmet::cmatrix_ref</A> 
wrap an expression arround C styled vectors and arrays. They create a <A 
class=el title="Const value iterator for ET." 
href="http://tvmet.sourceforge.net/classtvmet_1_1VectorConstReference.html">tvmet::VectorConstReference</A> 
respective a <A class=el title="value iterator for ET" 
href="http://tvmet.sourceforge.net/classtvmet_1_1MatrixConstReference.html">tvmet::MatrixConstReference</A> 
with a const pointer to the base address. This means that you can not modify the 
contents of the C styled vector/arrays by <A class=el 
title="The namespace for the Tiny Vector Matrix using Expression Templates Libary." 
href="http://tvmet.sourceforge.net/namespacetvmet.html">tvmet</A>, 
<DL class=user compact>
  <DT><B>e.g. writing</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keywordtype>int</SPAN> myarr[3];
   tvmet::cvector_ref&lt;int,3&gt;(myarr) = 1,2,3;
</PRE></DIV></DD></DL>won't work. <A class=el 
title="The namespace for the Tiny Vector Matrix using Expression Templates Libary." 
href="http://tvmet.sourceforge.net/namespacetvmet.html">tvmet</A> is not a 
wrapper for math arround C style arrays. It would not be a problem to write a 
non-const vector_ref/matrix_ref function with appropriate VectorReference 
respective MatrixReference but there is no direct way to get the results back 
into the C style arrays later - it was a design decision of <A class=el 
title="The namespace for the Tiny Vector Matrix using Expression Templates Libary." 
href="http://tvmet.sourceforge.net/namespacetvmet.html">tvmet</A>. Therefore you 
must copy the result into.
<H2><A class=anchor name=compare>Compare Vectors and Matrices</A></H2>If you 
expect to find global comparison operators for comparing Vectors and Matrices, 
you are right -- these are provided. But, the return value probably isn't what 
you expect: a boolean value. Instead, the operator returns an expression (e.g. 
XprVector&lt;&gt;). The contents of this expression type is a element wise 
logical operation (depends on the given operator like ==, &lt;, &gt;, etc...)! 
To get a boolean value you need to evaluate the expression using <A class=el 
title="check on statements for all elements" 
href="http://tvmet.sourceforge.net/group____unary__function.html#g1196da158222e0b5d71b574054c13f1b">all_elements()</A> 
or <A class=el title="check on statements for any elements" 
href="http://tvmet.sourceforge.net/group____unary__function.html#g7aca96ffb1f272123c90a5fd25be95d6">any_elements()</A>, 
as follows:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keyword>using namespace </SPAN>tvmet;
   <SPAN class=keyword>using namespace </SPAN>std;

   Vector&lt;double, 3&gt; v1, v2, bv;

   v1 = 1,2,3;
   v2 = 1,3,3;

   bv = v1 == v2;

   cout &lt;&lt; bv &lt;&lt; endl;
   cout &lt;&lt; <SPAN class=stringliteral>"v1 == v2 is "</SPAN>
        &lt;&lt; ( <A class=code title="check on statements for all elements" href="http://tvmet.sourceforge.net/group____unary__function.html#g1196da158222e0b5d71b574054c13f1b">all_elements</A>( v1 == v2 ) ? <SPAN class=stringliteral>"true"</SPAN> : <SPAN class=stringliteral>"false"</SPAN> )
        &lt;&lt; endl;
</PRE></DIV></DD></DL>This gives
<P>
<DL class=user compact>
  <DT><B>[continued]</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   Vector&lt;d, 3&gt;[1, 0, 1]
   v1 == v2 is <SPAN class=keyword>false</SPAN>
</PRE></DIV></DD></DL>The reason for this is the element wise operation on all 
elements (for both Vectors and Matrices). Comparing two vectors will result in a 
"boolean Vector" expression. Using all_elements/any_elements evaluates the 
result into a single boolean by repeatedly applying the comparison for each 
element.
<P>An other example on comparing is shown below:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keywordflow>if</SPAN>(<A class=code title="check on statements for all elements" href="http://tvmet.sourceforge.net/group____unary__function.html#g1196da158222e0b5d71b574054c13f1b">all_elements</A>(X == Y)) { cout &lt;&lt; <SPAN class=stringliteral>"matrices are identical"</SPAN> &lt;&lt; endl; }
   <SPAN class=keywordflow>if</SPAN>(<A class=code title="check on statements for any elements" href="http://tvmet.sourceforge.net/group____unary__function.html#g7aca96ffb1f272123c90a5fd25be95d6">any_elements</A>(X == Y)) { cout &lt;&lt; <SPAN class=stringliteral>"at least one element is equal"</SPAN> &lt;&lt; endl; }
   <SPAN class=keywordflow>if</SPAN>(<A class=code title="check on statements for any elements" href="http://tvmet.sourceforge.net/group____unary__function.html#g7aca96ffb1f272123c90a5fd25be95d6">any_elements</A>(X != Y)) { cout &lt;&lt; <SPAN class=stringliteral>"not all elements are equal"</SPAN> &lt;&lt; endl; }
</PRE></DIV></DD></DL>tvmet prior release 1.2.1 did have a boolean version eval 
for comparing. The functional and semantic meaning were not clear at all. 
Therefore I decided to remove it.
<P>
<DL class=see compact>
  <DT><B>See also:</B>
  <DD><A class=el href="http://tvmet.sourceforge.net/notes.html#operators">... 
  on operators and namespace element_wise</A></DD></DL>
<H2><A class=anchor name=pod>Data Types like std::complex&lt;&gt;</A></H2>As we 
can see above we can use POD (plain old data) types like <CODE>double</CODE> and 
<CODE>int</CODE> as data type of a Vector or Matrix. However, we are not limited 
to this - we can use e.g. <CODE>std::complex&lt;&gt;</CODE> as well:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keyword>using namespace </SPAN>tvmet;

   Vector&lt;std::complex&lt;double&gt;,3&gt; v1, v2;
   Matrix&lt;std::complex&lt;double&gt;,3,3&gt; m1;
</PRE></DIV></DD></DL>And operate on these...
<P>
<DL class=user compact>
  <DT><B>[continued]</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   v1 = 1,2,3;
   m1 = 1,4,7,
        2,5,8,
        3,6,9;
   v2 = m1 * v1;
</PRE></DIV></DD></DL>Be careful. <CODE>std::complex&lt;&gt;</CODE> isn't tested 
well on regression tests.
<H2><A class=anchor name=stl>STL support</A></H2>Since version 0.2.0 tvmet has 
supported an iterator interface conform to the STL and since version 0.5.0 
reverse STL iterators have been supported, too.
<P>With these, you can mix the tvmet Vector and Matrix containers with the STL 
algorithms.
<P>For example, if you don't like tvmet's ostream operator, you can create your 
own implementation like this:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <A class=code title="Compile time fixed length vector with evaluation on compile time." href="http://tvmet.sourceforge.net/classtvmet_1_1Vector.html">tvmet::Vector&lt;double, 6&gt;</A> v(1,2,3,4,5,6);
   std::cout &lt;&lt; v &lt;&lt; std::endl;

   std::cout &lt;&lt; <SPAN class=stringliteral>"The Vector is:"</SPAN> &lt;&lt; std::endl;
   std::copy(v.begin(), v.end(), std::ostream_iterator&lt;double&gt;(std::cout, <SPAN class=stringliteral>"\n"</SPAN>));
</PRE></DIV></DD></DL>Or, you create a random matrix and print it as shown here:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <A class=code title="A tiny matrix class." href="http://tvmet.sourceforge.net/classtvmet_1_1Matrix.html">tvmet::Matrix&lt;double,6,6&gt;</A> m;

   std::generate(m.<A class=code title="STL iterator interface." href="http://tvmet.sourceforge.net/classtvmet_1_1Matrix.html#813733b1267a8ab6ad59e813aaa1030c">begin</A>(), m.<A class=code title="STL iterator interface." href="http://tvmet.sourceforge.net/classtvmet_1_1Matrix.html#126b614c38c24fcb7a2106665519c2a3">end</A>(), rand);
   std::cout &lt;&lt; m &lt;&lt; std::endl;
</PRE></DIV></DD></DL>
<H2><A class=anchor name=matrix_access>Matrix access by rows and 
columns</A></H2>If you need a specific row or column of a given matrix you can 
get access to it by using the functions row and col. They will return an 
XprVector&lt;T&gt;. Unfortunately, you do not get any write access to the vector 
elements - only reading is permitted due to the expression template concept used 
here. For write access, you have to use matrix indexing with the parentheses 
operator.
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   <SPAN class=keyword>using namespace </SPAN>tvmet;

   <SPAN class=keyword>typedef</SPAN> Matrix&lt;double, 5, 3&gt;     matrix_type;
   <SPAN class=keyword>typedef</SPAN> Vector&lt;double, 5&gt;      matrix_rowvector;
   <SPAN class=keyword>typedef</SPAN> Vector&lt;double, 3&gt;      matrix_colvector;

   matrix_type M;
   M = ....

   matrix_rowvector row2 = <A class=code title="Returns a row vector of the given matrix." href="http://tvmet.sourceforge.net/group____binary__function.html#g2264e9f421471180dfcf25793024ebda">row</A>(M, 1);
   matrix_colvector col3 = <A class=code title="Returns a column vector of the given matrix." href="http://tvmet.sourceforge.net/group____binary__function.html#gffc27a9280d8b4e8a6cd52515d72adfa">col</A>(M, 2);
   ...
</PRE></DIV></DD></DL>
<H2><A class=anchor name=expr_print>Expression printing</A></H2>Expression 
printing is a nice feature for debugging expressions. (For more about expression 
templates and expression tree please have a look <A 
href="http://extreme.indiana.edu/~tveldhui/papers/Expression-Templates/exprtmpl.html>">here</A>).
<P>You can write out a simple matrix-vector multiplication of a vector 
<CODE>v1</CODE> and a matrix <CODE>m1</CODE> of the dimension of 3 as follows:
<P>
<DL class=user compact>
  <DT><B>Example:</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   std::cout &lt;&lt; m1 * v1 &lt;&lt; std::endl;
</PRE></DIV></DD></DL>which will be expanded to:
<P>
<DL class=user compact>
  <DT><B>[continued]</B>
  <DD>
  <DIV class=fragment><PRE class=fragment>   XprVector&lt;
       XprMVProduct&lt;
           d, 3, 3, 3, 1, d, 1
       &gt;
       3
   &gt;
</PRE></DIV></DD></DL>The "d" is a g++ placeholder for double. (This may vary 
from compiler to compiler since it is an implementation detail of runtime type 
information [rtti] determined by the compiler's manufacturer). The purpose of 
this feature is to check the right evaluation of expressions into the tree on 
complicated mathematical expressions.
<P>A rich source of examples are the regression tests. They show all of the 
supported operations and functions (if there is a regression test for this of 
course). Some examples are in the examples directory. 
<HR>

<TABLE width="100%">
  <TBODY>
  <TR>
    <TD vAlign=center align=right width="20%">Author:<BR>
      <SCRIPT language=JavaScript>
	       var m_name="opetzold";
	       var m_domain="users.sourceforge.net";
	       var m_text='<a href="mailto:'+m_name+'@'+m_domain+'?subject=tvmet 1.7.2">';
	       m_text+='Olaf Petzold</a>';
	       document.write(m_text);
      </SCRIPT>
    </TD></TR></TBODY></TABLE></BODY></HTML>
