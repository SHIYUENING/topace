//Fragment Shader

// Note how the fragment struct was simply copied from our vertex shader code.
// This is necessary if we want to use a vertex and pixel shader together.

struct fragment
{
    float4 position	:	POSITION;
    float4 color0	:	COLOR0;
    float2 texcoord0	:	TEXCOORD0;
    float3 normal	:	TEXCOORD1;
    float3 objectPos	:	TEXCOORD2;
};

struct pixel
{
    float4 color : COLOR;
};

pixel main( 
    fragment IN, 
    uniform float3	globalAmbient,
    uniform float3	paraLightColor,
    uniform float3	paraLightDirection,
    uniform float3	eyePosition,
	uniform float3	FogColor,
    uniform sampler2D	testTexture
)
{
    float3 P = IN.position.xyz;
    float3 NN =tex2D( testTexture, IN.texcoord0*10 );

	float3 N;
	N.x=(NN.x-0.5)*2.0;
	N.y=(NN.z-0.5)*2.0;
	N.z=(NN.y-0.5)*2.0;

    float3 L = normalize(paraLightDirection-P);
    float diffuseLight = max(dot(N, L), 0);
    float3 diffuse = paraLightColor * diffuseLight;


    float3 V = normalize(eyePosition - P);
    float3 H = normalize(L + V);
    float specularLight = pow(max(dot(N, H), 0), 100.0);

	if(diffuseLight<=0) specularLight=0;


	float fogb=min((100000-IN.objectPos.z)/40000,1.0);
	

   float3 global=globalAmbient;
   global.r=0;
   global.g=0;

   
    float4 Ocolor;
	
	
    Ocolor.xyz = global+diffuse*0.5+specularLight*paraLightColor;

    Ocolor.w = 1.0;

    pixel OUT;

	float4 Ocolor2;
	Ocolor2.xyz=(1-fogb)*FogColor;
	Ocolor2.w=(1-fogb);


	OUT.color = Ocolor*fogb+Ocolor2;
	//if((IN.objectPos.x*IN.objectPos.x+IN.objectPos.y*IN.objectPos.y+IN.objectPos.z*IN.objectPos.z)>10000*10000) OUT.color.xyz=FogColor;
    return OUT;
}
