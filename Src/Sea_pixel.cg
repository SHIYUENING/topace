//Fragment Shader

// Note how the fragment struct was simply copied from our vertex shader code.
// This is necessary if we want to use a vertex and pixel shader together.

struct fragment
{
    float4 position	:	POSITION;
    float4 color0	:	COLOR0;
    float2 texcoord0	:	TEXCOORD0;
    float3 normal	:	TEXCOORD1;
    float3 objectPos	:	TEXCOORD2;
};

struct pixel
{
    float4 color : COLOR;
};

pixel main( 
    fragment IN, 
    uniform float3	globalAmbient,
    uniform float3	paraLightColor,
    uniform float3	paraLightDirection,
    uniform float3	eyePosition,
	uniform float3	FogColor,
	//uniform float	time,
    uniform sampler2D	testTexture,
	uniform samplerCUBE	AmbientReflectiveTexturSea
)
{
    float3 P = IN.position.xyz;
    float3 NN =tex2D( testTexture, IN.texcoord0*12)*0.5+tex2D( testTexture, IN.texcoord0*10)*0.5;
	float3 N;
	N.x=(NN.x-0.5)*2.0;
	N.y=(NN.z-0.5)*1.0;
	N.z=(NN.y-0.5)*2.0;
    float3 diffuse;
	diffuse.r=0.0;
	diffuse.g=0.0;
	diffuse.b=1.0;
	float fogb=min((100000-IN.objectPos.z)/70000,1.0);
    float4 Ocolor;
    Ocolor.w = 1.0;
    pixel OUT;
	float4 Ocolor2;
	Ocolor2.xyz=(1-fogb)*FogColor;
	Ocolor2.w=(1-fogb);
	float3 V=-normalize(IN.objectPos-eyePosition);
	float eDotN = dot(V, N);
	float3 vEyeReflected = 2* eDotN * N - V;
	float4 reflection = texCUBE(AmbientReflectiveTexturSea, vEyeReflected);
	float Fresnel = (1 - eDotN)*reflection.g ;
	Ocolor.xyz=Fresnel*reflection.xyz*0.5+(1-Fresnel*0.5)*diffuse*globalAmbient;
	OUT.color = Ocolor*fogb+Ocolor2;
    return OUT;
}
