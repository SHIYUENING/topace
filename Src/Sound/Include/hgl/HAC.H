#ifndef HGL_HAC_INCLUDE
#define HGL_HAC_INCLUDE

#include<hgl/Thread.H>
#include<hgl/List.H>
#include<hgl/String.H>
namespace hgl
{
	class Semaphore;
	class Stream;
	class MemStream;
	class FileStream;

	enum HacStatus //: uint
	{
		hsNone=0,		//未知

		hsNotFind,		//没有找到

		hsOpenError,	//打开错误

		hsRead,			//正在读取

		hsReadError,	//读取错误

		hsEnd			//完成结束
	};

	/**
	* HAC包裹文件支持类,可以设定一个子目录以HAC方式访问,用以方便开发。<br>
	* 在制作发行版时直接将整个目录打包为.HAC即可.<br>
	* 另外，它不支持HAC-2的HAC文件。<br>
	*/
	class HAC:public Thread                                                                        	///HAC-3包裹文件支持类
	{
		friend HAC *OpenHAC(const wchar_t *);

	private:

		struct HacLoadItem
		{
        	Mutex mutex;

			void *folder;
			String filename;

			void *file;
			int start;
			int length;

            bool join_data;

			void *data;

			HacStatus status;

			HacLoadItem()
			{
				data=NULL;
			}

			~HacLoadItem()
			{
				if(!join_data&&data)
                	delete[] data;
			}

			void ChangeStatus(HacStatus hs)
			{
				mutex.Acquire();
				status=hs;
				mutex.Release();
			}
		};

		Semaphore *sem;
		Mutex quit_mutex;

		bool all_clear;

		ObjectList<HacLoadItem> load_queue;		//加载队列
		ObjectList<HacLoadItem> fin_queue;		//完成队列

		void Execute();

		void *_LoadAcquire(void *,const wchar_t *,void *,void *,int,int);

		virtual bool LoadFilePart(void *,uint,uint,void *)=0;

	protected:
	
		void CloseThread();

	public:

		HAC();                                                                                    	///<本类构造函数
		virtual ~HAC();                                                                           	///<本类析构函数

		/**
		* 查找一个文件，确定其是否存在
		* @param filename 要查找的文件名称
		* @return 文件是否存在
		*/
		virtual bool 		FindFile(const wchar_t *filename)=0;                                    ///<查找一个文件

		/**
		* 加载一个文件到流中，并返回这个流
		* @param filename 要加载的文件名称
		* @param load_to_memory 是否加载到内存
		* @return 保存文件数据的流，如果加载失败返回NULL
		*/
		virtual Stream *	LoadFile(const wchar_t *filename,bool load_to_memory=false)=0;          ///<加载一个文件到流

		/**
		* 加载一个文件到内存中
		* @param filename 要加载的文件名称
		* @param data 要用来保存数据的内存块
		* @param size 内存块的大小，以及加载成功后文件的大小
		* @return 是否加载成功
		*/
		virtual bool 		LoadFile(const wchar_t *filename,void **data,int *size)=0;              ///<加载一个文件到指定内存块

	public:

		/**
		* 取得一个目录
		* @param pathname 目录名称
		* @return 目录指针,返回NULL表示失败
		*/
		virtual void *		GetFolder(const wchar_t *pathname)=0;									///<取得一个目录

		/**
		* 取得目录内的文件数量
		* @param path_pointer 目录指针
		* @return 文件数量 
		*/
		virtual int 		GetFileCount(void *path_pointer)=0;										///<取得目录下的文件数量

		/**
		* 取得目录内指定的第index个文件的信息
		* @param path_pointer 目录指针
		* @param index 要取的文件索引
		* @param name 取出的文件名
		* @param size 取出的文件长度
		* @return 是否成功
		*/
		virtual bool 		GetFileInfo(void *path_pointer,int index,String &name,int &size)=0;		///<取得文件信息

		/**
		* 在指定目录内取得一个文件
		* @param path_pointer 目录指针
		* @param filename 文件名
		* @return 文件指针
		*/
		virtual void *		GetFile(void *path_pointer,const wchar_t *filename,int *filelength=0)=0;

		/**
		* 取得一个文件
		* @param filename 文件名
		* @return 文件指针
		*/
		virtual void *		GetFile(const wchar_t *filename,int *filelength=0)=0;

	public:                 
	           
		/**
		* 查找一个文件，确定其是否存在       
		* @param path_pointer 目录指针
		* @param filename 要查找的文件名称
		* @return 文件是否存在
		*/
		virtual bool 		FindFile(void *path_pointer,const wchar_t *filename)=0;                                    ///<查找一个文件
                      
		/**
		* 加载一个文件到流中，并返回这个流  
		* @param path_pointer 目录指针
		* @param filename 要加载的文件名称
		* @param load_to_memory 是否加载到内存
		* @return 保存文件数据的流，如果加载失败返回NULL
		*/
		virtual Stream *	LoadFileFrom(void *path_pointer,const wchar_t *filename,bool load_to_memory=false)=0;          ///<加载一个文件到流

		/**
		* 加载一个文件到内存中
		* @param path_pointer 目录指针
		* @param filename 要加载的文件名称
		* @param data 要用来保存数据的内存块
		* @param size 内存块的大小，以及加载成功后文件的大小
		* @return 是否加载成功
		*/
		virtual bool 		LoadFileFrom(void *path_pointer,const wchar_t *filename,void **data,int *size)=0;              ///<加载一个文件到指定内存块

	public:

		/**
		* 异步请求读取一个文件的指定部分到内存
		* @param filename 要加载的文件名称
		* @param data 加载后数据存放地址
		* @param start 要加载数据在文件中的起始地址
		* @param length 要加载数据的长度
		* @return 文件访问指针
		*/
		void *LoadAcquire(const wchar_t *filename,void *data=0,int start=0,int length=0)							///<异步请求取一个文件
		{	return _LoadAcquire(NULL,filename,NULL,data,start,length); }

		/**
		* 异步请求读取一个文件的指定部分到内存
		* @param path_pointer 目录指针
		* @param filename 要加载的文件名称 
		* @param data 加载后数据存放地址
		* @param start 要加载数据在文件中的起始地址
		* @param length 要加载数据的长度
		* @return 文件访问指针
		*/
		void *LoadAcquire(void *path_pointer,const wchar_t *filename,void *data=0,int start=0,int length=0)		///<异步请求取一个文件
		{	return _LoadAcquire(path_pointer,filename,NULL,data,start,length);}

		/**
		* 异步请求读取一个文件的指定部分到内存
		* @param file_pointer 要加载的文件指针      
		* @param data 加载后数据存放地址
		* @param start 要加载数据在文件中的起始地址
		* @param length 要加载数据的长度
		* @return 文件访问指针
		*/
		void *LoadAcquire(void *file_pointer,void *data=0,int start=0,int length=0)								///<异步请求取一个文件
		{	return _LoadAcquire(NULL,NULL,file_pointer,data,start,length);}

		/**
		* 取得一个文件读取的现有状态
		* @param file_pointer 文件访问指针
		* @return 状态
		*/
		HacStatus GetStatus(void *);

		/**
		* 取得一个请求的数据长度
		* @param file_pointer 文件访问指针
		*/
		int GetSize(void *);

		/**
		* 取得一个文件的数据(如果读取完成的话)
		* @param file_pointer 文件访问指针
		* @return 数据指针，如果未完成返回NULL
		*/
		void *GetData(void *);

		/**
		* 清除文件      
		* @param file_pointer 文件访问指针
		*/
		void Clear(void *);

		/**
		* 清除所有正在加载的文件
		*/
		void Clear();
	};

	HAC *OpenHAC(const wchar_t *name=0);                                                            ///<打开一个.HAC文件,或是根据路径创建一个虚拟的HAC环境
}
#endif//HGL_HAC_INCLUDE