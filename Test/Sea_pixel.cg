//Fragment Shader

// Note how the fragment struct was simply copied from our vertex shader code.
// This is necessary if we want to use a vertex and pixel shader together.

struct fragment
{
    float4 position	:	POSITION;
    float4 color0	:	COLOR0;
    float4 objectPos2	:	TEXCOORD0;
	float2 TexCoord1	:	TEXCOORD1;
	float2 TexCoord2	:	TEXCOORD2;
	float2 TexCoord3	:	TEXCOORD3;
	float2 TexCoord4	:	TEXCOORD4;
};

struct pixel
{
    float4 color : COLOR;
};

pixel main( 
    fragment IN, 
    uniform float3	globalAmbient,
    uniform float3	paraLightColor,
    uniform float3	paraLightDirection,
    uniform float3	eyePosition,
	uniform float3	FogColor,
	//uniform float	time,
    uniform sampler2D	testTexture,
	uniform samplerCUBE	AmbientReflectiveTexturSea
)
{

float3 vBumpTexA = tex2D(testTexture, IN.TexCoord1).xyz;
float3 vBumpTexB = tex2D(testTexture, IN.TexCoord2).xyz;
float3 vBumpTexC = tex2D(testTexture, IN.TexCoord3).xyz;
float3 vBumpTexD = tex2D(testTexture, IN.TexCoord4).xyz;

// Average bump layers
float3 N = normalize(2.0 * (vBumpTexA.xyz + vBumpTexB.xyz + vBumpTexC.xyz + vBumpTexD.xyz)-4.0);
float3 vReflBump = N * float3(0.9, 0.9, 1.0);


    float3 diffuse;
	diffuse.r=0.0;
	diffuse.g=0.0;
	diffuse.b=1.0;

    float4 Ocolor;
    Ocolor.w = 1.0;
    pixel OUT;

	float3 objpos;
	objpos.x=IN.objectPos2.x;
	objpos.y=IN.objectPos2.y;
	objpos.z=IN.objectPos2.z;
	float3 V=normalize(eyePosition-objpos);
	V=-V;

	float eDotN = max(dot(V, vReflBump),0.0);
	float3 vEyeReflected = reflect(V, vReflBump);
	float4 reflection = texCUBE(AmbientReflectiveTexturSea, vEyeReflected);
	//float Fresnel = (1 - eDotN);

	// Compute Fresnel term
float NdotL = max( dot(V, vReflBump), 0.0);
float facing = (1.0 - NdotL);
float Fresnel = max( 0.2 + 0.8 * pow(facing, 5.0), 0.0 );
	Ocolor.xyz=Fresnel*reflection.xyz*(1-globalAmbient)+(1-Fresnel)*diffuse*globalAmbient;
	OUT.color = Ocolor;
	float tmpG=OUT.color.g;
	float tmpB=OUT.color.b;
	OUT.color.g=tmpB;
	OUT.color.b=tmpG;
	OUT.color.a=(tmpG+tmpB+OUT.color.r)*4.0;
    return OUT;
}
